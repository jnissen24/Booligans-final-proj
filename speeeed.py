# -*- coding: utf-8 -*-
"""speeeed.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XV5tjgkJfA4O0Bf3Gx6KB42UnU9LBqOs

<a href="https://colab.research.google.com/github/jnissen24/Booligans-final-proj/blob/main/speeeed.ipynb"
target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>
"""

# PSUEDOCODE/OUTLINE:
# display rules/object of game
# set up game board
# create deck of cards; shuffle/randomize
# deal two stacks of 20 and two stacks of 5 all face down, two individual cards face up/displayed
# assign one stack of 20 to computer, the other to active player
# start game
# each player gets the first 5 cards of their 20 face-up
# variables: computer_cards, player_cards, standby1, standby2, wrkcard1, wrkcard2, computer_hand + player_hand
# can play a card from their 5 if it is +1 or -1 of either of the two face-up cards;
# this card becomes the new face-up card
# when a card is played, player then replenishes hand of 5 by drawing from personal pile
# this occurs until no cards are left - player wins by getting rid of cards first
# exceptions
# if neither player can use their in-hand cards to be +1 or -1 of the two working face-up cards,
# then two new working cards can be flipped, one from each of the two waiting piles of 5
# once all of these have been used, all of the previous working cards (except the two on top)
# are shuffled and used to draw from once more

import random


# creates Card class
import pygame


class Card:
    def __init__(self, suit, val):
        self.suit = suit
        self.value = val

    def show(self):
        print("{}{}".format(self.value, self.suit))

    def getstr(self):
        str = '{}{}'.format(self.value, self.suit)
        return str


# creates Deck class
class Deck:
    def __init__(self):
        self.cards = []
        self.build()
        self.computer_cards = []
        self.player_cards = []
        self.standby1 = []
        self.standby2 = []
        self.wrkcard1 = []
        self.wrkcard2 = []
        self.shuffle()
        self.deal()

    # assigns each card a suit and a value
    # labels for cards now match labels of images
    def build(self):
        for ii in ["S", "C", "D", "H"]:
            for jj in range(1, 14):  # ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"]:
                self.cards.append(Card(ii, jj))

    # Shuffles the deck by switching the card at index ii with a card at a random index
    def shuffle(self):
        for ii in range(len(self.cards)):
            r = random.randint(0, ii)
            self.cards[ii], self.cards[r] = self.cards[r], self.cards[ii]

    # Display the shuffled deck
    def show(self):
        for c in self.cards:
            c.show()

    # Deals cards to player and computer and also sets up standby decks and the middle cards
    def deal(self):
        self.computer_cards = self.cards[:20]
        self.player_cards = self.cards[20:40]
        self.standby1 = self.cards[40:45]
        self.standby2 = self.cards[45:50]
        self.wrkcard1 = self.cards[50]
        self.wrkcard2 = self.cards[51]


# function to obtain value of individual card
def card_value(card):
    if card == "AD":
        value = 1
    elif card == "AC":
        value = 1
    elif card == "AH":
        value = 1
    elif card == "AS":
        value = 1
    elif card == "2D":
        value = 2
    elif card == "2C":
        value = 2
    elif card == "2H":
        value = 2
    elif card == "2S":
        value = 2
    elif card == "3D":
        value = 3
    elif card == "3C":
        value = 3
    elif card == "3H":
        value = 3
    elif card == "3S":
        value = 3
    elif card == "4D":
        value = 4
    elif card == "4C":
        value = 4
    elif card == "4H":
        value = 4
    elif card == "4S":
        value = 4
    elif card == "5D":
        value = 5
    elif card == "5C":
        value = 5
    elif card == "5H":
        value = 5
    elif card == "5S":
        value = 5
    elif card == "6D":
        value = 6
    elif card == "6C":
        value = 6
    elif card == "6H":
        value = 6
    elif card == "6S":
        value = 6
    elif card == "7D":
        value = 7
    elif card == "7C":
        value = 7
    elif card == "7H":
        value = 7
    elif card == "7S":
        value = 7
    elif card == "8D":
        value = 8
    elif card == "8C":
        value = 8
    elif card == "8H":
        value = 8
    elif card == "8S":
        value = 8
    elif card == "9D":
        value = 9
    elif card == "9C":
        value = 9
    elif card == "9H":
        value = 9
    elif card == "9S":
        value = 9
    elif card == "10D":
        value = 10
    elif card == "10C":
        value = 10
    elif card == "10H":
        value = 10
    elif card == "10S":
        value = 10
    elif card == "JD":
        value = 11
    elif card == "JC":
        value = 11
    elif card == "JH":
        value = 11
    elif card == "JS":
        value = 11
    elif card == "QD":
        value = 12
    elif card == "QC":
        value = 12
    elif card == "QH":
        value = 12
    elif card == "QS":
        value = 12
    elif card == "KD":
        value = 13
    elif card == "KC":
        value = 13
    elif card == "KH":
        value = 13
    elif card == "KS":
        value = 13
    else:
        value = 0
    return value


def showDeck(mydeck):
    mystr = ''
    for c in mydeck:
        mystr = mystr + ',' + c.getstr()
    print(mystr)

def displayStatus(deck, computer_hand):
    print('Standby1 : ')
    showDeck(deck.standby1)

    print('Standby2 : ')
    showDeck(deck.standby2)

    print('Wrkcard1 : ')
    deck.wrkcard1.show()

    print('Wrkcard2 : ')
    deck.wrkcard2.show()

    print('Computer Hand:')
    showDeck(computer_hand)

    print('Computer Cards: ')
    showDeck(deck.computer_cards)


### ACTUAL GAME STARTS ###
deck = Deck()
# print statement for wrkcard since only has one object
#print(deck.wrkcard1.show())
#print(deck.wrkcard2.show())
# print statement for all other piles
#print([x.show() for x in deck.computer_cards])
#print([x.show() for x in deck.player_cards])

# take first 5 cards of each player's stack to be in active hand
computer_hand = []
player_hand = []
for i in range(0, 5):
    computer_hand.append(deck.computer_cards[i])
    player_hand.append(deck.player_cards[i])  # this used to be deck.computer_cards but should be this maybe?

deck.computer_cards.pop(0)
deck.computer_cards.pop(0)
deck.computer_cards.pop(0)
deck.computer_cards.pop(0)
deck.computer_cards.pop(0)
deck.player_cards.pop(0)
deck.player_cards.pop(0)
deck.player_cards.pop(0)
deck.player_cards.pop(0)
deck.player_cards.pop(0)




# print([x.show() for x in computer_hand])
# print([x.show() for x in player_hand])

# loop for game play

# print(card_value("KC"))
# print("done")

game_over = False
while not game_over:
    count = 0
    count_player = 0
    displayStatus(deck, computer_hand)
    while len(computer_hand) > 0 and (not game_over) and (count < len(computer_hand)):
        #import ipdb; ipdb.set_trace()
        item = computer_hand[count]
        count = count + 1
        length_comp = len(computer_hand)

        if (item.value == (deck.wrkcard1.value + 1)) or (item.value == (deck.wrkcard1.value - 1)) or (item.value == 13 and (deck.wrkcard1.value == 1)) or (item.value == 1 and (deck.wrkcard1.value == 13)):
            deck.standby1.append(deck.wrkcard1)  # keeps deck.wrkcard1 at holding one thing
            deck.wrkcard1 = item
            computer_hand.pop(count-1)
            if len(deck.computer_cards) > 0:
                computer_hand.append(deck.computer_cards[0])
                deck.computer_cards.pop(0)
                count = 0
            else:
                count = 0

            print('Replace working card 1')
            displayStatus(deck, computer_hand)
        elif (item.value == (deck.wrkcard2.value + 1)) or (item.value == (deck.wrkcard2.value - 1)) or (item.value == 13 and (deck.wrkcard2.value == 1)) or (item.value == 1 and (deck.wrkcard2.value == 13)):
            deck.standby2.append(deck.wrkcard2)
            deck.wrkcard2 = item
            computer_hand.pop(count-1)
            if len(deck.computer_cards) > 0:
                computer_hand.append(deck.computer_cards[0])
                deck.computer_cards.pop(0)
                count = 0
            else:
                count = 0
            print('Replace working card 2')
            displayStatus(deck, computer_hand)
        elif count == length_comp:
            count = 0
            deck.wrkcard1 = deck.standby1[0]
            card = deck.standby1.pop(0)
            deck.standby1.append(card)

            deck.wrkcard2 = deck.standby2[0]
            card = deck.standby2.pop(0)
            deck.standby2.append(card)

            print('Flip')
            displayStatus(deck, computer_hand)
        else:
            pass

    if len(deck.computer_cards) == 0 and len(computer_hand) == 0:
        print('Computer has won the game!')
        game_over = True

import pygame
for event in pygame.event.get():
    if event.type == pygame.QUIT:
        quit_game()
    if event.type == pygame.KEYDOWN:
        if event.key == pygame.K_1:
            if (player_hand[0].value == (deck.wrkcard1.value + 1)) or (player_hand[0].value == (deck.wrkcard1.value - 1)) or (player_hand[0].value == 13 and (deck.wrkcard1.value == 1)) or (player_hand[0].value == 1 and (deck.wrkcard1.value == 13)):
                deck.standby1.append(deck.wrkcard1)
                deck.wrkcard1 = player_hand[0]
                player_hand.pop(0)
                if len(deck.player_cards) > 0:
                    player_hand.append(deck.player_cards[0])
                    deck.player_cards.pop(0)
            elif (player_hand[0].value == (deck.wrkcard2.value + 1)) or (player_hand[0].value == (deck.wrkcard2.value - 1)) or (player_hand[0].value == 13 and (deck.wrkcard2.value == 1)) or (player_hand[0].value == 1 and (deck.wrkcard2.value == 13)):
                deck.standby2.append(deck.wrkcard2)
                deck.wrkcard2 = player_hand[0]
                player_hand.pop(0)
                if len(deck.player_cards) > 0:
                    player_hand.append(deck.player_cards[0])
                    deck.player_cards.pop(0)
            else:
                print('Error - this card cannot be played')
        elif event.key == pygame.K_2:
            if (player_hand[1].value == (deck.wrkcard1.value + 1)) or (player_hand[1].value == (deck.wrkcard1.value - 1)) or (player_hand[1].value == 13 and (deck.wrkcard1.value == 1)) or (player_hand[1].value == 1 and (deck.wrkcard1.value == 13)):
                deck.standby1.append(deck.wrkcard1)
                deck.wrkcard1 = player_hand[1]
                player_hand.pop(1)
                if len(deck.player_cards) > 0:
                    player_hand.append(deck.player_cards[0])
                    deck.player_cards.pop(0)
            elif (player_hand[1].value == (deck.wrkcard2.value + 1)) or (player_hand[1].value == (deck.wrkcard2.value - 1)) or (player_hand[1].value == 13 and (deck.wrkcard2.value == 1)) or (player_hand[1].value == 1 and (deck.wrkcard2.value == 13)):
                deck.standby2.append(deck.wrkcard2)
                deck.wrkcard2 = player_hand[1]
                player_hand.pop(1)
                if len(deck.player_cards) > 0:
                    player_hand.append(deck.player_cards[0])
                    deck.player_cards.pop(0)
            else:
                print('Error - this card cannot be played')
        elif event.key == pygame.K_3:
            if (player_hand[2].value == (deck.wrkcard1.value + 1)) or (player_hand[2].value == (deck.wrkcard1.value - 1)) or (player_hand[2].value == 13 and (deck.wrkcard1.value == 1)) or (player_hand[2].value == 1 and (deck.wrkcard1.value == 13)):
                deck.standby1.append(deck.wrkcard1)
                deck.wrkcard1 = player_hand[2]
                player_hand.pop(2)
                if len(deck.player_cards) > 0:
                    player_hand.append(deck.player_cards[0])
                    deck.player_cards.pop(0)
            elif (player_hand[2].value == (deck.wrkcard2.value + 1)) or (player_hand[2].value == (deck.wrkcard2.value - 1)) or (player_hand[2].value == 13 and (deck.wrkcard2.value == 1)) or (player_hand[2].value == 1 and (deck.wrkcard2.value == 13)):
                deck.standby2.append(deck.wrkcard2)
                deck.wrkcard2 = player_hand[2]
                player_hand.pop(2)
                if len(deck.player_cards) > 0:
                    player_hand.append(deck.player_cards[0])
                    deck.player_cards.pop(0)
            else:
                print('Error - this card cannot be played')
        elif event.key == pygame.K_4:
            if (player_hand[3].value == (deck.wrkcard1.value + 1)) or (player_hand[3].value == (deck.wrkcard1.value - 1)) or (player_hand[3].value == 13 and (deck.wrkcard1.value == 1)) or (player_hand[3].value == 1 and (deck.wrkcard1.value == 13)):
                deck.standby1.append(deck.wrkcard1)
                deck.wrkcard1 = player_hand[3]
                player_hand.pop(3)
                if len(deck.player_cards) > 0:
                    player_hand.append(deck.player_cards[0])
                    deck.player_cards.pop(0)
            elif (player_hand[3].value == (deck.wrkcard2.value + 1)) or (player_hand[3].value == (deck.wrkcard2.value - 1)) or (player_hand[3].value == 13 and (deck.wrkcard2.value == 1)) or (player_hand[3].value == 1 and (deck.wrkcard2.value == 13)):
                deck.standby2.append(deck.wrkcard2)
                deck.wrkcard2 = player_hand[3]
                player_hand.pop(3)
                if len(deck.player_cards) > 0:
                    player_hand.append(deck.player_cards[0])
                    deck.player_cards.pop(0)
            else:
                print('Error - this card cannot be played')
        elif event.key == pygame.K_5:
            if (player_hand[4].value == (deck.wrkcard1.value + 1)) or (player_hand[0].value == (deck.wrkcard1.value - 1)) or (player_hand[4].value == 13 and (deck.wrkcard1.value == 1)) or (player_hand[4].value == 1 and (deck.wrkcard1.value == 13)):
                deck.standby1.append(deck.wrkcard1)
                deck.wrkcard1 = player_hand[4]
                player_hand.pop(4)
                if len(deck.player_cards) > 0:
                    player_hand.append(deck.player_cards[0])
                    deck.player_cards.pop(0)
            elif (player_hand[4].value == (deck.wrkcard2.value + 1)) or (player_hand[4].value == (deck.wrkcard2.value - 1)) or (player_hand[4].value == 13 and (deck.wrkcard2.value == 1)) or (player_hand[4].value == 1 and (deck.wrkcard2.value == 13)):
                deck.standby2.append(deck.wrkcard2)
                deck.wrkcard2 = player_hand[4]
                player_hand.pop(4)
                if len(deck.player_cards) > 0:
                    player_hand.append(deck.player_cards[0])
                    deck.player_cards.pop(0)
            else:
                print('Error - this card cannot be played')
        else:
            print('User cannot go; need new working cards')
