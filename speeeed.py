# -*- coding: utf-8 -*-
"""speeeed.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XV5tjgkJfA4O0Bf3Gx6KB42UnU9LBqOs

<a href="https://colab.research.google.com/github/jnissen24/Booligans-final-proj/blob/main/speeeed.ipynb"
target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>
"""

# PSUEDOCODE/OUTLINE:
# display rules/object of game
# set up game board
# create deck of cards; shuffle/randomize
# deal two stacks of 20 and two stacks of 5 all face down, two individual cards face up/displayed
# assign one stack of 20 to computer, the other to active player
# start game
# each player gets the first 5 cards of their 20 face-up
# variables: computer_cards, player_cards, standby1, standby2, wrkcard1, wrkcard2, computer_hand + player_hand
# can play a card from their 5 if it is +1 or -1 of either of the two face-up cards;
# this card becomes the new face-up card
# when a card is played, player then replenishes hand of 5 by drawing from personal pile
# this occurs until no cards are left - player wins by getting rid of cards first
# exceptions
# if neither player can use their in-hand cards to be +1 or -1 of the two working face-up cards,
# then two new working cards can be flipped, one from each of the two waiting piles of 5
# once all of these have been used, all of the previous working cards (except the two on top)
# are shuffled and used to draw from once more

import random 
# creates Card class
class Card:
  def __init__(self, suit, val):
    self.suit = suit
    self.value = val

  def show(self):
    print("{}{}".format(self.value, self.suit))

# creates Deck class
class Deck:
  def __init__(self):
    self.cards = []
    self.build()
    self.computer_cards = []
    self.player_cards = []
    self.standby1 = []
    self.standby2 = []
    self.wrkcard1 = []
    self.wrkcard2 = []
    self.shuffle()
    self.deal()
  
# assigns each card a suit and a value
# labels for cards now match labels of images
  def build(self): 
    for ii in ["S", "C", "D", "H"]:
      for jj in ["A", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"]:
        self.cards.append(Card(ii, jj))
  
# Shuffles the deck by switching the card at index ii with a card at a random index
  def shuffle(self):
    for ii in range(len(self.cards)):
      r = random.randint(0, ii)
      self.cards[ii], self.cards[r] = self.cards[r], self.cards[ii]

# Display the shuffled deck
  def show(self):
    for c in self.cards:
      c.show()

# Deals cards to player and computer and also sets up standby decks and the middle cards
  def deal(self):
    self.computer_cards = self.cards[:20]
    self.player_cards = self.cards[20:40]
    self.standby1 = self.cards[40:45]
    self.standby2 = self.cards[45:50]
    self.wrkcard1 = self.cards[50]
    self.wrkcard2 = self.cards[51]

deck = Deck()
# print statement for wrkcard since only has one object
print(deck.wrkcard1.show())
print(deck.wrkcard2.show())
# print statement for all other piles
print([x.show() for x in deck.computer_cards])
print([x.show() for x in deck.player_cards])

# take first 5 cards of each player's stack to be in active hand
computer_hand = []
player_hand = []
for i in range(0, 5):
  computer_hand.append(deck.computer_cards[i])
  player_hand.append(deck.player_cards[i]) #this used to be deck.computer_cards but should be this maybe?

print([x.show() for x in computer_hand])
print([x.show() for x in player_hand])

# function to obtain value of individual card
def card_value():
  if "AD" or "AC" or "AH" or "AS":
    value = 1
  elif "2D" or "2C" or "2H" or "2S":
    value = 2
  elif "3D" or "3C" or "3H" or "3S":
    value = 3
  elif "4D" or "4C" or "4H" or "4S":
    value = 4
  elif "5D" or "5C" or "5H" or "5S":
    value = 5
  elif "6D" or "6C" or "6H" or "6S":
    value = 6
  elif "7D" or "7C" or "7H" or "7S":
    value = 7
  elif "8D" or "8C" or "8H" or "8S":
    value = 8
  elif "9D" or "9C" or "9H" or "9S":
    value = 9
  elif "10D" or "10C" or "10H" or "10S":
    value = 10
  elif "JD" or "JC" or "JH" or "JS":
    value = 11
  elif "QD" or "QC" or "QH" or "QS":
    value = 12
  elif "KD" or "KC" or "KH" or "KS":
    value = 13
  else:
    value = 0
# loop for game play
while 1:
  count = 0
  count_player = 0
  for item in computer_hand:
    count = count + 1
    length_comp = len(computer_hand)
    print(item)
    if item == deck.wrkcard1[0] + 1 or deck.wrkcard1[0] - 1:
      deck.wrkcard1.append(item)
      deck.standby1.append(deck.wrkcard1[0]) #keeps deck.wrkcard1 at holding one thing
      deck.wrkcard1.pop(0) #gets rid of the card?
      computer_hand.append(deck.computer_cards[0])
      deck.computer_cards.pop(0)
    elif item == deck.wrkcard2[0] + 1 or deck.wrkcard2[0] - 1:
      deck.wrkcard2.append(item)
      deck.standby2.append(deck.wrkcard1[0])
      deck.wrkcard2.pop(0)
      computer_hand.append(deck.computer_cards[0])
      deck.computer_cards.pop(0)
    elif count == length_comp:
      count = 0
      deck.wrkcard1.append(deck.standby1[0])
      deck.wrkcard1.pop(0)
      deck.wrkcard2.append(deck.standby2[0])
      deck.standby2.pop(0)
    # need a case for when there are no more cards to be compared!

  for item in player_hand:
    count_player = count_player + 1
    length_player = len(player_hand)
    if item == deck.wrkcard1 + 1 or deck.wrkcard1 - 1:
      deck.wrkcard1.append(item)
      deck.standby1.append(deck.wrkcard1[0])
      deck.wrkcard1.pop(0)
      player_hand.append(deck.player_cards[0])
      deck.player_cards.pop(0)
    elif item == deck.wrkcard2 + 1 or deck.wrkcard2 - 1:
      deck.wrkcard2.append(item)
      deck.standby2.append(deck.wrkcard2[0])
      deck.wrkcard2.pop(0)
      player_hand.append(deck.player_cards[0])
      deck.player_cards.pop(0)
    elif count_player == length_player:
      count = 0
      deck.wrkcard1.append(deck.standby1[0])
      deck.wrkcard1.pop(0)
      deck.wrkcard2.append(deck.standby2[0])
      deck.standby2.pop(0)